<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Otter River Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: 'Orbitron', sans-serif;
        }
        
        body {
            margin: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #333;
            position: fixed;
            touch-action: none;
            font-size: 14px;
        }
        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
        }
        #score {
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        #timer {
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        #lives {
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        .life {
            width: 30px;
            height: 30px;
            background: #ff4444;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            transition: all 0.3s ease;
        }
        .life.lost {
            transform: scale(0.5);
            opacity: 0.5;
        }
        #level {
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        #home-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 2000;
            padding: 10px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        #home-screen h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #4CAF50;
        }
        #home-screen h2 {
            font-size: 18px;
            margin: 8px 0;
            color: #2196F3;
        }
        #home-screen p {
            margin: 5px 0;
            font-size: 14px;
        }
        .section {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 10px;
            margin: 5px 0;
            width: 95%;
            max-width: 400px;
        }
        .unlockable {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            font-size: 12px;
        }
        .unlockable.locked {
            opacity: 0.5;
        }
        .unlockable button {
            padding: 3px 8px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 12px;
            touch-action: manipulation;
        }
        .unlockable button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .points-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin: 5px 0;
            font-size: 12px;
        }
        .point-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #start-button {
            padding: 10px 20px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 10px;
            transition: transform 0.2s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        #start-button:active {
            transform: scale(0.95);
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #left-control, #right-control {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            margin: 0 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
            user-select: none;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .collapsible {
            width: 100%;
            text-align: left;
            background: rgba(255,255,255,0.1);
            border: none;
            outline: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            margin: 2px 0;
            color: white;
            font-size: 14px;
            touch-action: manipulation;
        }
        .collapsible:after {
            content: '‚ñº';
            float: right;
            margin-left: 5px;
        }
        .collapsible.active:after {
            content: '‚ñ≤';
        }
        .content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.2s ease-out;
        }
        .content.active {
            max-height: 500px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-ui">
            <div id="score">Score: 0</div>
            <div id="timer">Time: 30</div>
            <div id="lives">
                <div class="life"></div>
                <div class="life"></div>
                <div class="life"></div>
            </div>
            <div id="level">Level: 1</div>
        </div>
        <div id="home-screen">
            <h1>Otter River Adventure</h1>
            <p>A fun 3D game where you control an otter collecting fish and avoiding obstacles in a river!</p>
            
            <button class="collapsible">How to Play</button>
            <div class="content">
                <div class="section">
                    <p>Use the controls at the bottom to move</p>
                    <p>üéØ Collect fish and clams while avoiding obstacles</p>
                    <p>‚ö° Game speeds up as you level up</p>
                    <p>‚ú® Rarer fish appear at higher levels</p>
                </div>
            </div>

            <button class="collapsible">Point Distribution</button>
            <div class="content">
                <div class="section">
                    <div class="points-grid">
                        <div class="point-item">üêü Normal Fish: 1 point</div>
                        <div class="point-item">üåà Rainbow Fish: 3 points</div>
                        <div class="point-item">üåü Golden Fish: 5 points</div>
                        <div class="point-item">üíé Emerald Fish: 7 points</div>
                        <div class="point-item">üí† Diamond Fish: 10 points</div>
                        <div class="point-item">ü¶™ Clam: 15 points</div>
                        <div class="point-item">üê† Seahorse: 8 points</div>
                        <div class="point-item">üêô Jellyfish: 12 points</div>
                        <div class="point-item">‚≠ê Starfish: 6 points</div>
                    </div>
                </div>
            </div>

            <button class="collapsible">Top Scores</button>
            <div class="content">
                <div class="section">
                    <div id="top-scores"></div>
                </div>
            </div>

            <button class="collapsible">Unlockables</button>
            <div class="content">
                <div class="section">
                    <div class="unlockable">
                        <span>üé© Top Hat</span>
                        <span>Unlocked!</span>
                        <button onclick="wearHat()">Wear</button>
                    </div>
                    <div class="unlockable locked">
                        <span>üëë Crown</span>
                        <span>Locked (300+ points)</span>
                        <button disabled>Wear</button>
                    </div>
                </div>
            </div>

            <button id="start-button">Start Adventure!</button>
        </div>
        <div id="controls">
            <div id="left-control">‚Üê</div>
            <div id="right-control">‚Üí</div>
        </div>
    </div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let gameInstance = null;

        // Add collapsible functionality
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Content Loaded');
            
            // Initialize game
            const container = document.getElementById('game-container');
            if (container) {
                console.log('Container found, initializing game');
                gameInstance = new OtterRiverGame(container);
                
                // Add start button listener
                const startButton = document.getElementById('start-button');
                if (startButton) {
                    console.log('Start button found, adding listeners');
                    
                    function handleStart() {
                        console.log('Start button activated');
                        if (gameInstance) {
                            gameInstance.startGame();
                        }
                    }
                    
                    startButton.addEventListener('touchstart', handleStart);
                    startButton.addEventListener('click', handleStart);
                } else {
                    console.error('Start button not found');
                }

                // Add wear hat button listener
                const hatButton = document.querySelector('.unlockable button');
                if (hatButton) {
                    function handleHat() {
                        if (gameInstance) {
                            gameInstance.wearHat();
                        }
                    }
                    
                    hatButton.addEventListener('touchstart', handleHat);
                    hatButton.addEventListener('click', handleHat);
                }
            } else {
                console.error('Game container not found');
            }

            // Add collapsible functionality
            const coll = document.getElementsByClassName("collapsible");
            for (let i = 0; i < coll.length; i++) {
                const element = coll[i];
                
                function handleCollapse() {
                    this.classList.toggle("active");
                    const content = this.nextElementSibling;
                    if (content.style.maxHeight) {
                        content.style.maxHeight = null;
                        content.classList.remove("active");
                    } else {
                        content.style.maxHeight = content.scrollHeight + "px";
                        content.classList.add("active");
                    }
                }
                
                element.addEventListener("touchstart", handleCollapse);
                element.addEventListener("click", handleCollapse);
            }
        });

        // Game code
        class OtterRiverGame {
            constructor(container) {
                console.log('Game constructor called');
                this.container = container;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.clock = new THREE.Clock();
                this.obstacles = [];
                this.collectibles = [];
                this.score = 0;
                this.level = 1;
                this.gameOver = false;
                this.otter = null;
                this.river = null;
                this.isPlaying = false;
                this.moveDirection = 0;
                this.moveSpeed = 0.2;
                this.obstacleSpeed = 0.2;
                this.spawnRate = 0.02;
                this.collectibleSpawnRate = 0.01;
                this.topScores = JSON.parse(localStorage.getItem('topScores')) || [];
                this.unlockedItems = JSON.parse(localStorage.getItem('unlockedItems')) || ['topHat'];
                this.gameLoopRunning = false;
                this.lives = 3;
                this.levelTimer = 30;
                this.lastLevelTime = Date.now();
                
                console.log('Initializing game...');
                this.init();
                console.log('Game initialized');
            }

            init() {
                console.log('Game init called');
                // Renderer setup
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;  // Increased exposure for better lighting
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.container.appendChild(this.renderer.domElement);

                // Setup camera
                this.camera.position.set(0, 4, 8);
                this.camera.lookAt(0, 0, -20);
                this.camera.fov = 70;
                this.camera.updateProjectionMatrix();

                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);  // Reduced ambient light
                this.scene.add(ambientLight);

                // Main directional light with shadows
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);  // Increased intensity
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -20;
                directionalLight.shadow.camera.right = 20;
                directionalLight.shadow.camera.top = 20;
                directionalLight.shadow.camera.bottom = -20;
                directionalLight.shadow.bias = -0.0001;  // Reduced shadow acne
                this.scene.add(directionalLight);

                // Add a subtle point light for better depth
                const pointLight = new THREE.PointLight(0xffffff, 0.6);  // Increased intensity
                pointLight.position.set(0, 10, 0);
                this.scene.add(pointLight);

                // Add a blue-tinted light for water effect
                const waterLight = new THREE.PointLight(0x1E90FF, 0.3);  // Dodger blue tint
                waterLight.position.set(0, 0, 0);
                this.scene.add(waterLight);

                // Create environment
                this.createEnvironment();

                // Create river
                this.createRiver();

                // Load otter model
                this.loadOtter();

                // Add event listeners
                this.setupControls();
                window.addEventListener('resize', this.onWindowResize.bind(this));

                // Update top scores display
                this.updateTopScores();

                // Start initial render
                this.renderer.render(this.scene, this.camera);
            }

            createEnvironment() {
                // Create sky with gradient
                const skyGeometry = new THREE.SphereGeometry(100, 32, 32);
                const skyMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        topColor: { value: new THREE.Color(0x0077ff) },
                        bottomColor: { value: new THREE.Color(0xffffff) },
                        offset: { value: 33 },
                        exponent: { value: 0.6 }
                    },
                    vertexShader: `
                        varying vec3 vWorldPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 topColor;
                        uniform vec3 bottomColor;
                        uniform float offset;
                        uniform float exponent;
                        varying vec3 vWorldPosition;
                        void main() {
                            float h = normalize(vWorldPosition + offset).y;
                            gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                        }
                    `,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);

                // Create ground with better material
                const groundGeometry = new THREE.PlaneGeometry(100, 100);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1E90FF,
                    roughness: 0.2,
                    metalness: 0.3,
                    transparent: true,
                    opacity: 0.8,
                    envMapIntensity: 1.0
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.5;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Create clouds with better material
                this.clouds = [];
                for (let i = 0; i < 10; i++) {
                    const cloudGeometry = new THREE.SphereGeometry(Math.random() * 2 + 1, 16, 16);
                    const cloudMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.8,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0.9
                    });
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloud.position.set(
                        (Math.random() - 0.5) * 100,
                        Math.random() * 20 + 10,
                        (Math.random() - 0.5) * 100
                    );
                    cloud.userData.speed = Math.random() * 0.02 + 0.01;
                    cloud.castShadow = true;
                    cloud.receiveShadow = true;
                    this.clouds.push(cloud);
                    this.scene.add(cloud);
                }
            }

            createRiver() {
                // Create river bed with enhanced material
                const riverGeometry = new THREE.PlaneGeometry(40, 1000);
                const riverMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1E90FF,
                    roughness: 0.2,
                    metalness: 0.3,
                    transparent: true,
                    opacity: 0.8,
                    envMapIntensity: 1.0
                });
                this.water = new THREE.Mesh(riverGeometry, riverMaterial);
                this.water.rotation.x = -Math.PI / 2;
                this.water.position.y = -0.5;
                this.water.receiveShadow = true;
                this.scene.add(this.water);
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            updateTopScores() {
                const topScoresDiv = document.getElementById('top-scores');
                topScoresDiv.innerHTML = this.topScores
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 5)
                    .map((score, index) => `${index + 1}. ${score.score} points`)
                    .join('<br>');
            }

            wearHat() {
                if (this.unlockedItems.includes('topHat')) {
                    // Remove any existing hat
                    const existingHat = this.otter.children.find(child => child.userData.isHat);
                    if (existingHat) {
                        this.otter.remove(existingHat);
                    }

                    // Create hat group
                    const hat = new THREE.Group();
                    hat.userData.isHat = true;

                    // Create hat brim (torus)
                    const brimGeometry = new THREE.TorusGeometry(0.25, 0.05, 16, 32);
                    const brimMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        roughness: 0.7,
                        metalness: 0.2
                    });
                    const brim = new THREE.Mesh(brimGeometry, brimMaterial);
                    brim.rotation.x = Math.PI / 2;
                    hat.add(brim);

                    // Create hat top (cylinder)
                    const topGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.4, 32);
                    const topMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        roughness: 0.7,
                        metalness: 0.2
                    });
                    const top = new THREE.Mesh(topGeometry, topMaterial);
                    top.position.y = 0.25;  // Position above brim
                    hat.add(top);

                    // Position hat on otter's head
                    hat.position.set(0, 0.5, -0.7);  // Adjusted to sit properly on head
                    hat.rotation.y = Math.PI / 2;  // Match head rotation
                    this.otter.add(hat);
                }
            }

            wearCrown() {
                if (this.unlockedItems.includes('crown')) {
                    // Remove any existing crown
                    const existingCrown = this.otter.children.find(child => child.userData.isCrown);
                    if (existingCrown) {
                        this.otter.remove(existingCrown);
                    }

                    // Add crown to otter model
                    const crownGeometry = new THREE.ConeGeometry(0.3, 0.4, 8);
                    const crownMaterial = new THREE.MeshStandardMaterial({
                        color: 0xFFD700,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    const crown = new THREE.Mesh(crownGeometry, crownMaterial);
                    crown.position.set(0, 0.8, 0);
                    crown.userData.isCrown = true;
                    this.otter.add(crown);
                }
            }

            spawnCollectible() {
                const types = [
                    { type: 'normalFish', points: 1, color: 0x808080, chance: 0.4, shape: 'fish' },
                    { type: 'rainbowFish', points: 3, color: 0xFF69B4, chance: 0.2, shape: 'fish' },
                    { type: 'goldenFish', points: 5, color: 0xFFD700, chance: 0.15, shape: 'fish' },
                    { type: 'emeraldFish', points: 7, color: 0x00FF00, chance: 0.1, shape: 'fish' },
                    { type: 'diamondFish', points: 10, color: 0x00FFFF, chance: 0.05, shape: 'fish' },
                    { type: 'clam', points: 15, color: 0xFFFFFF, chance: 0.05, shape: 'clam' },
                    { type: 'seahorse', points: 8, color: 0xFFA500, chance: 0.02, shape: 'seahorse' },
                    { type: 'jellyfish', points: 12, color: 0xFF00FF, chance: 0.02, shape: 'jellyfish' },
                    { type: 'starfish', points: 6, color: 0xFFFF00, chance: 0.01, shape: 'starfish' }
                ];

                // Adjust chances based on level
                const totalChance = types.reduce((sum, type) => sum + type.chance, 0);
                const random = Math.random() * totalChance;
                let currentSum = 0;
                let selectedType;

                for (const type of types) {
                    currentSum += type.chance;
                    if (random <= currentSum) {
                        selectedType = type;
                        break;
                    }
                }

                let geometry;
                switch(selectedType.shape) {
                    case 'fish':
                        // Create a more realistic fish shape
                        const fishShape = new THREE.Shape();
                        fishShape.moveTo(0, 0);
                        fishShape.bezierCurveTo(0.2, 0.1, 0.3, 0.2, 0.4, 0);
                        fishShape.bezierCurveTo(0.3, -0.2, 0.2, -0.1, 0, 0);
                        const fishExtrudeSettings = {
                            steps: 1,
                            depth: 0.1,
                            bevelEnabled: true,
                            bevelThickness: 0.1,
                            bevelSize: 0.1,
                            bevelSegments: 3
                        };
                        geometry = new THREE.ExtrudeGeometry(fishShape, fishExtrudeSettings);
                        break;
                    case 'clam':
                        geometry = new THREE.SphereGeometry(0.4, 16, 16);
                        break;
                    case 'seahorse':
                        geometry = new THREE.CylinderGeometry(0.1, 0.2, 0.8, 8);
                        break;
                    case 'jellyfish':
                        // Create a more realistic jellyfish shape
                        const jellyShape = new THREE.Shape();
                        jellyShape.moveTo(0, 0);
                        jellyShape.bezierCurveTo(0.2, 0.3, 0.4, 0.3, 0.5, 0);
                        jellyShape.bezierCurveTo(0.4, -0.3, 0.2, -0.3, 0, 0);
                        const jellyExtrudeSettings = {
                            steps: 1,
                            depth: 0.1,
                            bevelEnabled: true,
                            bevelThickness: 0.1,
                            bevelSize: 0.1,
                            bevelSegments: 3
                        };
                        geometry = new THREE.ExtrudeGeometry(jellyShape, jellyExtrudeSettings);
                        break;
                    case 'starfish':
                        geometry = new THREE.StarGeometry(0.4, 5, 0.2);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                }

                const material = new THREE.MeshStandardMaterial({
                    color: selectedType.color,
                    roughness: 0.7,
                    metalness: 0.3,
                    emissive: selectedType.color,
                    emissiveIntensity: 0.2
                });

                const collectible = new THREE.Mesh(geometry, material);
                collectible.position.x = (Math.random() - 0.5) * 12;
                collectible.position.z = -30;
                collectible.position.y = -0.3;
                collectible.rotation.y = Math.PI / 2;  // Face forward
                collectible.userData = {
                    type: selectedType.type,
                    points: selectedType.points
                };
                collectible.castShadow = true;

                this.scene.add(collectible);
                this.collectibles.push(collectible);
            }

            updateCollectibles() {
                for (let i = this.collectibles.length - 1; i >= 0; i--) {
                    const collectible = this.collectibles[i];
                    collectible.position.z += this.obstacleSpeed;

                    // Check collection
                    if (this.checkCollection(this.otter, collectible)) {
                        this.score += collectible.userData.points;
                        this.updateScore();
                        this.scene.remove(collectible);
                        this.collectibles.splice(i, 1);

                        // Check for crown unlock
                        if (this.score >= 300 && !this.unlockedItems.includes('crown')) {
                            this.unlockedItems.push('crown');
                            localStorage.setItem('unlockedItems', JSON.stringify(this.unlockedItems));
                            this.wearCrown();
                        }
                    }

                    // Remove collectibles that are behind the camera
                    if (collectible.position.z > 10) {
                        this.scene.remove(collectible);
                        this.collectibles.splice(i, 1);
                    }
                }
            }

            checkCollection(otter, collectible) {
                const distance = otter.position.distanceTo(collectible.position);
                return distance < 1;
            }

            startGame() {
                console.log('Start game called');
                this.isPlaying = true;
                this.gameOver = false;
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.levelTimer = 30;
                this.lastLevelTime = Date.now();
                this.obstacleSpeed = 0.2;
                this.spawnRate = 0.02;
                this.collectibleSpawnRate = 0.01;
                
                // Update UI
                this.updateScore();
                this.updateLives();
                this.updateLevel();
                
                // Hide home screen
                const homeScreen = document.getElementById('home-screen');
                if (homeScreen) {
                    console.log('Hiding home screen');
                    homeScreen.style.display = 'none';
                }
                
                // Reset otter position
                if (this.otter) {
                    console.log('Resetting otter position');
                    this.otter.position.set(0, 0, 0);
                }
                
                // Clear existing obstacles and collectibles
                this.obstacles.forEach(obstacle => this.scene.remove(obstacle));
                this.obstacles = [];
                this.collectibles.forEach(collectible => this.scene.remove(collectible));
                this.collectibles = [];
                
                // Start the game loop if it's not already running
                if (!this.gameLoopRunning) {
                    console.log('Starting game loop');
                    this.gameLoopRunning = true;
                    this.animate();
                }
            }

            showGameOver() {
                // Update top scores
                this.topScores.push({ score: this.score, date: new Date().toISOString() });
                this.topScores.sort((a, b) => b.score - a.score);
                this.topScores = this.topScores.slice(0, 10);
                localStorage.setItem('topScores', JSON.stringify(this.topScores));

                const gameOverDiv = document.createElement('div');
                gameOverDiv.style.position = 'absolute';
                gameOverDiv.style.top = '50%';
                gameOverDiv.style.left = '50%';
                gameOverDiv.style.transform = 'translate(-50%, -50%)';
                gameOverDiv.style.color = 'white';
                gameOverDiv.style.fontSize = '32px';
                gameOverDiv.style.textAlign = 'center';
                gameOverDiv.style.background = 'rgba(0,0,0,0.8)';
                gameOverDiv.style.padding = '20px';
                gameOverDiv.style.borderRadius = '10px';
                gameOverDiv.innerHTML = `Game Over!<br>Score: ${this.score}<br>Tap to restart`;
                
                this.container.appendChild(gameOverDiv);
                
                this.container.addEventListener('touchstart', () => {
                    location.reload();
                }, { once: true });
            }

            animate() {
                if (this.gameOver) {
                    console.log('Game over, stopping animation');
                    return;
                }

                requestAnimationFrame(this.animate.bind(this));

                if (this.isPlaying && !this.gameOver) {
                    // Update timer
                    const currentTime = Date.now();
                    const deltaTime = (currentTime - this.lastLevelTime) / 1000;
                    this.levelTimer -= deltaTime;
                    this.lastLevelTime = currentTime;
                    this.updateTimer();

                    // Level up every 30 seconds
                    if (this.levelTimer <= 0) {
                        this.level++;
                        this.levelTimer = 30;
                        this.obstacleSpeed += 0.05;
                        this.spawnRate += 0.005;
                        this.collectibleSpawnRate += 0.002;
                        this.updateLevel();
                    }

                    this.updateOtterPosition();
                }

                // Spawn obstacles randomly
                if (Math.random() < this.spawnRate) {
                    this.spawnObstacle();
                }

                // Spawn collectibles randomly
                if (Math.random() < this.collectibleSpawnRate) {
                    this.spawnCollectible();
                }

                this.updateObstacles();
                this.updateCollectibles();

                // Enhanced water animation
                const time = Date.now() * 0.001;
                if (this.water) {
                    const positions = this.water.geometry.attributes.position;
                    const vertex = new THREE.Vector3();
                    
                    for (let i = 0; i < positions.count; i++) {
                        vertex.fromBufferAttribute(positions, i);
                        // More complex wave pattern
                        vertex.y = Math.sin(time + vertex.x * 0.1 + vertex.z * 0.1) * 0.1 +
                                 Math.sin(time * 0.5 + vertex.x * 0.2 + vertex.z * 0.2) * 0.05;
                        positions.setY(i, vertex.y);
                    }
                    positions.needsUpdate = true;
                }

                // Enhanced cloud animation
                if (this.clouds) {
                    this.clouds.forEach(cloud => {
                        cloud.position.z += cloud.userData.speed;
                        // Add subtle floating motion
                        cloud.position.y += Math.sin(Date.now() * 0.001 + cloud.position.x) * 0.001;
                        if (cloud.position.z > 20) {
                            cloud.position.z = -100;
                            cloud.position.x = (Math.random() - 0.5) * 100;
                            cloud.position.y = Math.random() * 20 + 10;
                        }
                    });
                }

                this.renderer.render(this.scene, this.camera);
            }

            setupControls() {
                const leftControl = document.getElementById('left-control');
                const rightControl = document.getElementById('right-control');

                // Touch events for left control
                leftControl.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.moveDirection = -1;
                });
                leftControl.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.moveDirection === -1) this.moveDirection = 0;
                });
                leftControl.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    if (this.moveDirection === -1) this.moveDirection = 0;
                });

                // Touch events for right control
                rightControl.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.moveDirection = 1;
                });
                rightControl.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.moveDirection === 1) this.moveDirection = 0;
                });
                rightControl.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    if (this.moveDirection === 1) this.moveDirection = 0;
                });
            }

            loadOtter() {
                // Create otter group
                this.otter = new THREE.Group();
                this.otter.position.y = -0.9;  // Lower otter position to be in blue water
                this.otter.scale.set(0.8, 0.8, 0.8);
                this.scene.add(this.otter);

                // Create body
                const bodyGeometry = new THREE.SphereGeometry(0.4, 32, 32);  // Changed from CapsuleGeometry to SphereGeometry with more segments for smoother appearance
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.1;
                body.rotation.y = Math.PI / 2;
                body.scale.set(1.2, 0.8, 0.8);  // Adjusted scale to maintain similar proportions
                body.castShadow = true;
                this.otter.add(body);

                // Create head
                const headGeometry = new THREE.SphereGeometry(0.25, 32, 32);  // Increased segments for smoother appearance
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.set(0, 0.2, -0.7);
                head.rotation.y = Math.PI / 2;
                head.scale.set(1, 0.6, 0.8);
                head.castShadow = true;
                this.otter.add(head);

                // Create snout
                const snoutGeometry = new THREE.ConeGeometry(0.12, 0.25, 8);
                const snoutMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
                snout.position.set(0, 0.2, -0.9);  // Lowered from 0.4 to 0.2
                snout.rotation.x = Math.PI / 2;
                snout.rotation.y = Math.PI / 2;
                snout.scale.set(1, 0.6, 0.8);
                snout.castShadow = true;
                this.otter.add(snout);

                // Create eyes
                const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0x000000,
                    roughness: 0.3,
                    metalness: 0.8
                });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.12, 0.3, -0.8);  // Lowered from 0.5 to 0.3
                leftEye.rotation.y = Math.PI / 2;
                this.otter.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.12, 0.3, -0.8);  // Lowered from 0.5 to 0.3
                rightEye.rotation.y = Math.PI / 2;
                this.otter.add(rightEye);

                // Create ears (more otter-like)
                const earGeometry = new THREE.SphereGeometry(0.06, 32, 32);  // Smaller, full sphere for ears
                const earMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const leftEar = new THREE.Mesh(earGeometry, earMaterial);
                leftEar.position.set(0.12, 0.35, -0.65);  // Adjusted position to sit better on head
                leftEar.rotation.y = Math.PI / 2;
                this.otter.add(leftEar);
                const rightEar = new THREE.Mesh(earGeometry, earMaterial);
                rightEar.position.set(-0.12, 0.35, -0.65);  // Adjusted position to sit better on head
                rightEar.rotation.y = Math.PI / 2;
                this.otter.add(rightEar);

                // Create tail (more otter-like)
                const tailGeometry = new THREE.CapsuleGeometry(0.15, 0.6, 16, 32);  // Changed to capsule for more rounded tail
                const tailMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                tail.position.set(0, 0.1, 0.7);  // Adjusted position
                tail.rotation.y = Math.PI / 2;  // Match body rotation
                tail.rotation.z = Math.PI / 6;  // Slight upward angle
                tail.scale.set(1, 0.4, 1);  // Flattened slightly
                tail.castShadow = true;
                this.otter.add(tail);

                // Create legs (shorter)
                const legGeometry = new THREE.CapsuleGeometry(0.1, 0.2, 4, 8);  // Reduced leg length from 0.4 to 0.2
                const legMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
                frontLeftLeg.position.set(0.25, -0.1, -0.3);  // Lowered position
                frontLeftLeg.rotation.y = Math.PI / 2;
                frontLeftLeg.scale.set(1, 0.4, 1);
                frontLeftLeg.castShadow = true;
                this.otter.add(frontLeftLeg);
                const frontRightLeg = new THREE.Mesh(legGeometry, legMaterial);
                frontRightLeg.position.set(-0.25, -0.1, -0.3);  // Lowered position
                frontRightLeg.rotation.y = Math.PI / 2;
                frontRightLeg.scale.set(1, 0.4, 1);
                frontRightLeg.castShadow = true;
                this.otter.add(frontRightLeg);
                const backLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
                backLeftLeg.position.set(0.25, -0.1, 0.3);  // Lowered position
                backLeftLeg.rotation.y = Math.PI / 2;
                backLeftLeg.scale.set(1, 0.4, 1);
                backLeftLeg.castShadow = true;
                this.otter.add(backLeftLeg);
                const backRightLeg = new THREE.Mesh(legGeometry, legMaterial);
                backRightLeg.position.set(-0.25, -0.1, 0.3);  // Lowered position
                backRightLeg.rotation.y = Math.PI / 2;
                backRightLeg.scale.set(1, 0.4, 1);
                backRightLeg.castShadow = true;
                this.otter.add(backRightLeg);
            }

            updateObstacles() {
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    obstacle.position.z += this.obstacleSpeed;

                    // Check collision
                    if (this.checkCollision(this.otter, obstacle)) {
                        // Remove the obstacle after collision
                        this.scene.remove(obstacle);
                        this.obstacles.splice(i, 1);
                        continue;
                    }

                    // Remove obstacles that are behind the camera
                    if (obstacle.position.z > 10) {
                        this.scene.remove(obstacle);
                        this.obstacles.splice(i, 1);
                        this.score++;
                        this.updateScore();
                    }
                }
            }

            checkCollision(otter, obstacle) {
                const distance = otter.position.distanceTo(obstacle.position);
                const collisionRadius = obstacle.geometry.type === 'CylinderGeometry' ? 0.3 : 0.5;
                if (distance < collisionRadius) {
                    this.lives--;
                    this.updateLives();
                    
                    // Only end game when all lives are lost
                    if (this.lives <= 0) {
                        this.gameOver = true;
                        this.showGameOver();
                    }
                    return true;
                }
                return false;
            }

            spawnObstacle() {
                // 70% chance for rock, 30% chance for wooden pole
                const isRock = Math.random() < 0.7;
                let geometry, material;

                if (isRock) {
                    geometry = new THREE.DodecahedronGeometry(0.5, 0);
                    material = new THREE.MeshStandardMaterial({
                        color: 0x808080,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                } else {
                    // Create wooden pole with smaller collision box
                    geometry = new THREE.CylinderGeometry(0.15, 0.15, 2, 8);  // Reduced radius
                    material = new THREE.MeshStandardMaterial({
                        color: 0x8B4513,
                        roughness: 0.9,
                        metalness: 0.1
                    });
                }

                const obstacle = new THREE.Mesh(geometry, material);
                obstacle.position.x = (Math.random() - 0.5) * 12;
                obstacle.position.z = -30;
                obstacle.position.y = isRock ? -0.3 : 0.5;  // Rocks lower, poles higher
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;

                this.scene.add(obstacle);
                this.obstacles.push(obstacle);
            }

            updateScore() {
                const scoreElement = document.getElementById('score');
                if (scoreElement) {
                    scoreElement.textContent = `Score: ${this.score}`;
                }
            }

            updateOtterPosition() {
                if (this.otter) {
                    this.otter.position.x += this.moveDirection * this.moveSpeed;
                    // Keep otter within bounds
                    this.otter.position.x = Math.max(-8, Math.min(8, this.otter.position.x));
                }
            }

            updateLives() {
                const livesContainer = document.getElementById('lives');
                const lives = livesContainer.getElementsByClassName('life');
                for (let i = 0; i < lives.length; i++) {
                    lives[i].classList.toggle('lost', i >= this.lives);
                }
            }

            updateLevel() {
                const levelElement = document.getElementById('level');
                if (levelElement) {
                    levelElement.textContent = `Level: ${this.level}`;
                }
            }

            updateTimer() {
                const timerElement = document.getElementById('timer');
                if (timerElement) {
                    timerElement.textContent = `Time: ${Math.ceil(this.levelTimer)}`;
                }
            }
        }
    </script>
</body>
</html> 