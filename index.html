<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Otter River Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: 'Orbitron', sans-serif;
        }
        
        body {
            margin: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #333;
            position: fixed;
            touch-action: none;
            font-size: 14px;
        }
        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
        }
        #score, #timer, #lives, #level {
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            margin: 5px;
        }
        #lives {
            display: flex;
            gap: 10px;
        }
        .life {
            width: 30px;
            height: 30px;
            background: #ff4444;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            transition: all 0.3s ease;
        }
        .life.lost {
            transform: scale(0.5);
            opacity: 0.5;
        }
        #home-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 2000;
            padding: 10px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        #home-screen h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #4CAF50;
        }
        #home-screen h2 {
            font-size: 18px;
            margin: 8px 0;
            color: #2196F3;
        }
        #home-screen p {
            margin: 5px 0;
            font-size: 14px;
        }
        .section {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 10px;
            margin: 5px 0;
            width: 95%;
            max-width: 400px;
        }
        .unlockable {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            font-size: 12px;
        }
        .unlockable.locked {
            opacity: 0.5;
        }
        .unlockable button {
            padding: 3px 8px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 12px;
            touch-action: manipulation;
        }
        .unlockable button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .points-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin: 5px 0;
            font-size: 12px;
        }
        .point-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #start-button {
            padding: 10px 20px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 10px;
            transition: transform 0.2s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        #start-button:active {
            transform: scale(0.95);
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #joystick-base {
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
        }
        #joystick-knob {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .collapsible {
            width: 100%;
            text-align: left;
            background: rgba(255,255,255,0.1);
            border: none;
            outline: none;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            margin: 2px 0;
            color: white;
            font-size: 14px;
            touch-action: manipulation;
        }
        .collapsible:after {
            content: '‚ñº';
            float: right;
            margin-left: 5px;
        }
        .collapsible.active:after {
            content: '‚ñ≤';
        }
        .content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.2s ease-out;
        }
        .content.active {
            max-height: 500px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-ui">
            <div id="score">Score: 0</div>
            <div id="timer">Time: 30</div>
            <div id="lives">
                <div class="life"></div>
                <div class="life"></div>
                <div class="life"></div>
            </div>
            <div id="level">Level: 1</div>
        </div>
        <div id="home-screen">
            <h1>Otter River Adventure</h1>
            <p>A fun 3D game where you control an otter collecting fish and avoiding obstacles in a river!</p>
            
            <button class="collapsible">How to Play</button>
            <div class="content">
                <div class="section">
                    <p>Use the controls at the bottom to move</p>
                    <p>üéØ Collect fish and clams while avoiding obstacles</p>
                    <p>‚ö° Game speeds up as you level up</p>
                    <p>‚ú® Rarer fish appear at higher levels</p>
                </div>
            </div>

            <button class="collapsible">Point Distribution</button>
            <div class="content">
                <div class="section">
                    <div class="points-grid">
                        <div class="point-item">üêü Normal Fish: 1 point</div>
                        <div class="point-item">üåà Rainbow Fish: 3 points</div>
                        <div class="point-item">üåü Golden Fish: 5 points</div>
                        <div class="point-item">üíé Emerald Fish: 7 points</div>
                        <div class="point-item">üí† Diamond Fish: 10 points</div>
                        <div class="point-item">ü¶™ Clam: 15 points</div>
                        <div class="point-item">üê† Seahorse: 8 points</div>
                        <div class="point-item">üêô Jellyfish: 12 points</div>
                        <div class="point-item">‚≠ê Starfish: 6 points</div>
                    </div>
                </div>
            </div>

            <button class="collapsible">Top Scores</button>
            <div class="content">
                <div class="section">
                    <div id="top-scores"></div>
                </div>
            </div>

            <button class="collapsible">Unlockables</button>
            <div class="content">
                <div class="section">
                    <div class="unlockable">
                        <span>üé© Top Hat</span>
                        <span>Unlocked!</span>
                        <button onclick="wearHat()">Wear</button>
                    </div>
                    <div class="unlockable locked">
                        <span>üëë Crown</span>
                        <span>Locked (300+ points)</span>
                        <button disabled>Wear</button>
                    </div>
                </div>
            </div>

            <button id="start-button">Start Adventure!</button>
        </div>
        <div id="controls">
            <div id="joystick-base">
                <div id="joystick-knob"></div>
            </div>
        </div>
    </div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        let gameInstance = null;

        // Add collapsible functionality
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Content Loaded');
            
            // Initialize game
            const container = document.getElementById('game-container');
            if (container) {
                console.log('Container found, initializing game');
                gameInstance = new OtterRiverGame(container);
                
                // Add start button listener
                const startButton = document.getElementById('start-button');
                if (startButton) {
                    console.log('Start button found, adding listeners');
                    
                    function handleStart() {
                        console.log('Start button activated');
                        if (gameInstance) {
                            gameInstance.startGame();
                        }
                    }
                    
                    startButton.addEventListener('touchstart', handleStart);
                    startButton.addEventListener('click', handleStart);
                } else {
                    console.error('Start button not found');
                }

                // Add wear hat button listener
                const hatButton = document.querySelector('.unlockable button');
                if (hatButton) {
                    function handleHat() {
                        if (gameInstance) {
                            gameInstance.wearHat();
                        }
                    }
                    
                    hatButton.addEventListener('touchstart', handleHat);
                    hatButton.addEventListener('click', handleHat);
                }
            } else {
                console.error('Game container not found');
            }

            // Add collapsible functionality
            const coll = document.getElementsByClassName("collapsible");
            for (let i = 0; i < coll.length; i++) {
                const element = coll[i];
                
                function handleCollapse() {
                    this.classList.toggle("active");
                    const content = this.nextElementSibling;
                    if (content.style.maxHeight) {
                        content.style.maxHeight = null;
                        content.classList.remove("active");
                    } else {
                        content.style.maxHeight = content.scrollHeight + "px";
                        content.classList.add("active");
                    }
                }
                
                element.addEventListener("touchstart", handleCollapse);
                element.addEventListener("click", handleCollapse);
            }
        });

        // Game code
        class OtterRiverGame {
            constructor(container) {
                console.log('Game constructor called');
                this.container = container;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.clock = new THREE.Clock();
                this.obstacles = [];
                this.collectibles = [];
                this.score = 0;
                this.level = 1;
                this.gameOver = false;
                this.otter = null;
                this.river = null;
                this.isPlaying = false;
                this.moveDirection = 0;
                this.moveSpeed = 0.2;
                this.obstacleSpeed = 0.2;
                this.spawnRate = 0.02;
                this.collectibleSpawnRate = 0.01;
                this.topScores = JSON.parse(localStorage.getItem('topScores')) || [];
                this.unlockedItems = JSON.parse(localStorage.getItem('unlockedItems')) || ['topHat'];
                this.gameLoopRunning = false;
                this.lives = 3;
                this.levelTimer = 30;
                this.lastLevelTime = Date.now();
                
                console.log('Initializing game...');
                this.init();
                console.log('Game initialized');
            }

            init() {
                console.log('Game init called');
                // Renderer setup
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;  // Increased exposure for better lighting
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.container.appendChild(this.renderer.domElement);

                // Setup camera
                this.camera.position.set(0, 4, 8);
                this.camera.lookAt(0, 0, -20);
                this.camera.fov = 70;
                this.camera.updateProjectionMatrix();

                // Add lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);  // Reduced ambient light
                this.scene.add(ambientLight);

                // Main directional light with shadows
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);  // Increased intensity
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 50;
                directionalLight.shadow.camera.left = -20;
                directionalLight.shadow.camera.right = 20;
                directionalLight.shadow.camera.top = 20;
                directionalLight.shadow.camera.bottom = -20;
                directionalLight.shadow.bias = -0.0001;  // Reduced shadow acne
                this.scene.add(directionalLight);

                // Add a subtle point light for better depth
                const pointLight = new THREE.PointLight(0xffffff, 0.6);  // Increased intensity
                pointLight.position.set(0, 10, 0);
                this.scene.add(pointLight);

                // Add a blue-tinted light for water effect
                const waterLight = new THREE.PointLight(0x1E90FF, 0.3);  // Dodger blue tint
                waterLight.position.set(0, 0, 0);
                this.scene.add(waterLight);

                // Create environment
                this.createEnvironment();

                // Create river
                this.createRiver();

                // Load otter model
                this.loadOtter();

                // Add event listeners
                this.setupControls();
                window.addEventListener('resize', this.onWindowResize.bind(this));

                // Update top scores display
                this.updateTopScores();

                // Start initial render
                this.renderer.render(this.scene, this.camera);
            }

            createEnvironment() {
                // Create sky with gradient
                const skyGeometry = new THREE.SphereGeometry(100, 32, 32);
                const skyMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        topColor: { value: new THREE.Color(0x0077ff) },
                        bottomColor: { value: new THREE.Color(0xffffff) },
                        offset: { value: 33 },
                        exponent: { value: 0.6 }
                    },
                    vertexShader: `
                        varying vec3 vWorldPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 topColor;
                        uniform vec3 bottomColor;
                        uniform float offset;
                        uniform float exponent;
                        varying vec3 vWorldPosition;
                        void main() {
                            float h = normalize(vWorldPosition + offset).y;
                            gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                        }
                    `,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);

                // Create ground with better material
                const groundGeometry = new THREE.PlaneGeometry(100, 100);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1E90FF,
                    roughness: 0.2,
                    metalness: 0.3,
                    transparent: true,
                    opacity: 0.8,
                    envMapIntensity: 1.0
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.5;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Create clouds with better material
                this.clouds = [];
                for (let i = 0; i < 10; i++) {
                    const cloudGeometry = new THREE.SphereGeometry(Math.random() * 2 + 1, 16, 16);
                    const cloudMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.8,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0.9
                    });
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloud.position.set(
                        (Math.random() - 0.5) * 100,
                        Math.random() * 20 + 10,
                        (Math.random() - 0.5) * 100
                    );
                    cloud.userData.speed = Math.random() * 0.02 + 0.01;
                    cloud.castShadow = true;
                    cloud.receiveShadow = true;
                    this.clouds.push(cloud);
                    this.scene.add(cloud);
                }
            }

            createRiver() {
                // Create river bed with enhanced material
                const riverGeometry = new THREE.PlaneGeometry(40, 1000);
                const riverMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1E90FF,
                    roughness: 0.2,
                    metalness: 0.3,
                    transparent: true,
                    opacity: 0.8,
                    envMapIntensity: 1.0
                });
                this.water = new THREE.Mesh(riverGeometry, riverMaterial);
                this.water.rotation.x = -Math.PI / 2;
                this.water.position.y = -0.5;
                this.water.receiveShadow = true;
                this.scene.add(this.water);
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            updateTopScores() {
                const topScoresDiv = document.getElementById('top-scores');
                topScoresDiv.innerHTML = this.topScores
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 5)
                    .map((score, index) => `${index + 1}. ${score.score} points`)
                    .join('<br>');
            }

            wearHat() {
                if (this.unlockedItems.includes('topHat')) {
                    // Remove any existing hat
                    const existingHat = this.otter.children.find(child => child.userData.isHat);
                    if (existingHat) {
                        this.otter.remove(existingHat);
                    }

                    // Create hat group
                    const hat = new THREE.Group();
                    hat.userData.isHat = true;

                    // Create hat brim (torus)
                    const brimGeometry = new THREE.TorusGeometry(0.25, 0.05, 16, 32);
                    const brimMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        roughness: 0.7,
                        metalness: 0.2
                    });
                    const brim = new THREE.Mesh(brimGeometry, brimMaterial);
                    brim.rotation.x = Math.PI / 2;
                    hat.add(brim);

                    // Create hat top (cylinder with larger radius)
                    const topGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 32);
                    const topMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        roughness: 0.7,
                        metalness: 0.2
                    });
                    const top = new THREE.Mesh(topGeometry, topMaterial);
                    top.position.y = 0.25;  // Position above brim
                    hat.add(top);

                    // Position hat on otter's head
                    hat.position.set(0, 0.3, -0.7);  // Adjusted to sit properly on head
                    hat.rotation.y = Math.PI / 2;  // Match head rotation
                    this.otter.add(hat);
                }
            }

            wearCrown() {
                if (this.unlockedItems.includes('crown')) {
                    // Remove any existing crown
                    const existingCrown = this.otter.children.find(child => child.userData.isCrown);
                    if (existingCrown) {
                        this.otter.remove(existingCrown);
                    }

                    // Create crown group
                    const crown = new THREE.Group();
                    crown.userData.isCrown = true;

                    // Create base ring (torus)
                    const baseGeometry = new THREE.TorusGeometry(0.3, 0.05, 16, 32);
                    const baseMaterial = new THREE.MeshStandardMaterial({
                        color: 0xFFD700,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.rotation.x = Math.PI / 2;
                    crown.add(base);

                    // Create three triangular peaks
                    const peakGeometry = new THREE.ConeGeometry(0.15, 0.3, 3);
                    const peakMaterial = new THREE.MeshStandardMaterial({
                        color: 0xFFD700,
                        roughness: 0.3,
                        metalness: 0.8
                    });

                    // Add three peaks at different angles
                    for (let i = 0; i < 3; i++) {
                        const peak = new THREE.Mesh(peakGeometry, peakMaterial);
                        const angle = (i / 3) * Math.PI * 2;
                        peak.position.set(
                            Math.cos(angle) * 0.2,
                            0.2,
                            Math.sin(angle) * 0.2
                        );
                        peak.rotation.y = angle;
                        crown.add(peak);
                    }

                    // Position crown on otter's head
                    crown.position.set(0, 0.4, -0.7);
                    crown.rotation.y = Math.PI / 2;
                    this.otter.add(crown);
                }
            }

            spawnCollectible() {
                const types = [
                    { type: 'normalFish', points: 1, color: 0x808080, chance: 0.4, shape: 'fish', emoji: 'üêü' },
                    { type: 'rainbowFish', points: 3, color: 0xFF69B4, chance: 0.2, shape: 'fish', emoji: 'üåà' },
                    { type: 'goldenFish', points: 5, color: 0xFFD700, chance: 0.15, shape: 'fish', emoji: 'üåü' },
                    { type: 'emeraldFish', points: 7, color: 0x00FF00, chance: 0.1, shape: 'fish', emoji: 'üíé' },
                    { type: 'diamondFish', points: 10, color: 0x00FFFF, chance: 0.05, shape: 'fish', emoji: 'üí†' },
                    { type: 'clam', points: 15, color: 0xFFFFFF, chance: 0.05, shape: 'clam', emoji: 'ü¶™' },
                    { type: 'seahorse', points: 8, color: 0xFFA500, chance: 0.02, shape: 'seahorse', emoji: 'üê†' },
                    { type: 'jellyfish', points: 12, color: 0xFF00FF, chance: 0.02, shape: 'jellyfish', emoji: 'üêô' },
                    { type: 'starfish', points: 6, color: 0xFFFF00, chance: 0.01, shape: 'starfish', emoji: '‚≠ê' }
                ];

                // Adjust chances based on level
                const totalChance = types.reduce((sum, type) => sum + type.chance, 0);
                const random = Math.random() * totalChance;
                let currentSum = 0;
                let selectedType;

                for (const type of types) {
                    currentSum += type.chance;
                    if (random <= currentSum) {
                        selectedType = type;
                        break;
                    }
                }

                let collectible;
                if (selectedType.shape === 'fish') {
                    // Create fish group
                    collectible = new THREE.Group();
                    
                    // Create fish body (more streamlined)
                    const bodyGeometry = new THREE.CapsuleGeometry(0.15, 0.8, 8, 16);
                    const bodyMaterial = new THREE.MeshStandardMaterial({
                        color: selectedType.color,
                        roughness: 0.7,
                        metalness: 0.3,
                        emissive: selectedType.color,
                        emissiveIntensity: 0.2
                    });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.rotation.x = Math.PI / 2;
                    body.rotation.z = Math.PI / 2;
                    collectible.add(body);

                    // Create tail fin (more fish-like)
                    const tailGeometry = new THREE.Shape();
                    tailGeometry.moveTo(0, 0);
                    tailGeometry.lineTo(0.4, 0.2);
                    tailGeometry.lineTo(0.4, -0.2);
                    tailGeometry.lineTo(0, 0);
                    const tailExtrudeSettings = {
                        steps: 1,
                        depth: 0.05,
                        bevelEnabled: true,
                        bevelThickness: 0.02,
                        bevelSize: 0.02,
                        bevelSegments: 3
                    };
                    const tailMesh = new THREE.Mesh(
                        new THREE.ExtrudeGeometry(tailGeometry, tailExtrudeSettings),
                        bodyMaterial
                    );
                    tailMesh.position.set(0.4, 0, 0);
                    tailMesh.rotation.z = -Math.PI / 2;
                    collectible.add(tailMesh);

                    // Create dorsal fin (top)
                    const dorsalGeometry = new THREE.Shape();
                    dorsalGeometry.moveTo(0, 0);
                    dorsalGeometry.lineTo(0.2, 0.3);
                    dorsalGeometry.lineTo(0.4, 0);
                    dorsalGeometry.lineTo(0, 0);
                    const dorsalMesh = new THREE.Mesh(
                        new THREE.ExtrudeGeometry(dorsalGeometry, tailExtrudeSettings),
                        bodyMaterial
                    );
                    dorsalMesh.position.set(0, 0.2, 0);
                    dorsalMesh.rotation.x = Math.PI / 2;
                    collectible.add(dorsalMesh);

                    // Create pectoral fins (sides)
                    const pectoralGeometry = new THREE.Shape();
                    pectoralGeometry.moveTo(0, 0);
                    pectoralGeometry.lineTo(0.2, 0.1);
                    pectoralGeometry.lineTo(0.2, -0.1);
                    pectoralGeometry.lineTo(0, 0);
                    
                    // Left pectoral fin
                    const leftPectoral = new THREE.Mesh(
                        new THREE.ExtrudeGeometry(pectoralGeometry, tailExtrudeSettings),
                        bodyMaterial
                    );
                    leftPectoral.position.set(0, 0, 0.2);
                    leftPectoral.rotation.z = Math.PI / 2;
                    leftPectoral.rotation.y = Math.PI / 4;
                    collectible.add(leftPectoral);
                    
                    // Right pectoral fin
                    const rightPectoral = new THREE.Mesh(
                        new THREE.ExtrudeGeometry(pectoralGeometry, tailExtrudeSettings),
                        bodyMaterial
                    );
                    rightPectoral.position.set(0, 0, -0.2);
                    rightPectoral.rotation.z = -Math.PI / 2;
                    rightPectoral.rotation.y = -Math.PI / 4;
                    collectible.add(rightPectoral);

                    // Create pelvic fins (bottom)
                    const pelvicGeometry = new THREE.Shape();
                    pelvicGeometry.moveTo(0, 0);
                    pelvicGeometry.lineTo(0.15, 0.1);
                    pelvicGeometry.lineTo(0.15, -0.1);
                    pelvicGeometry.lineTo(0, 0);
                    
                    // Left pelvic fin
                    const leftPelvic = new THREE.Mesh(
                        new THREE.ExtrudeGeometry(pelvicGeometry, tailExtrudeSettings),
                        bodyMaterial
                    );
                    leftPelvic.position.set(0, -0.2, 0.1);
                    leftPelvic.rotation.z = -Math.PI / 2;
                    leftPelvic.rotation.y = Math.PI / 4;
                    collectible.add(leftPelvic);
                    
                    // Right pelvic fin
                    const rightPelvic = new THREE.Mesh(
                        new THREE.ExtrudeGeometry(pelvicGeometry, tailExtrudeSettings),
                        bodyMaterial
                    );
                    rightPelvic.position.set(0, -0.2, -0.1);
                    rightPelvic.rotation.z = -Math.PI / 2;
                    rightPelvic.rotation.y = -Math.PI / 4;
                    collectible.add(rightPelvic);

                    // Create small eyes
                    const eyeGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const eyeMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    
                    // Left eye
                    const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    leftEye.position.set(-0.2, 0.1, 0.1);
                    collectible.add(leftEye);
                    
                    // Right eye
                    const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    rightEye.position.set(-0.2, 0.1, -0.1);
                    collectible.add(rightEye);

                    // Add special effects based on fish type
                    switch(selectedType.type) {
                        case 'rainbowFish':
                            // Add rainbow trail
                            const trailGeometry = new THREE.CircleGeometry(0.2, 32);
                            const trailMaterial = new THREE.MeshBasicMaterial({
                                color: 0xFF69B4,
                                transparent: true,
                                opacity: 0.3,
                                side: THREE.DoubleSide
                            });
                            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                            trail.position.set(0.4, 0, 0);
                            trail.rotation.x = Math.PI / 2;
                            collectible.add(trail);
                            break;

                        case 'goldenFish':
                            // Add golden sparkles
                            for (let i = 0; i < 5; i++) {
                                const sparkleGeometry = new THREE.SphereGeometry(0.02, 8, 8);
                                const sparkleMaterial = new THREE.MeshBasicMaterial({
                                    color: 0xFFD700,
                                    transparent: true,
                                    opacity: 0.8
                                });
                                const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                                sparkle.position.set(
                                    (Math.random() - 0.5) * 0.4,
                                    (Math.random() - 0.5) * 0.4,
                                    (Math.random() - 0.5) * 0.4
                                );
                                collectible.add(sparkle);
                            }
                            break;

                        case 'emeraldFish':
                            // Add emerald glow
                            const emeraldGlowGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                            const emeraldGlowMaterial = new THREE.MeshBasicMaterial({
                                color: 0x00FF00,
                                transparent: true,
                                opacity: 0.2
                            });
                            const emeraldGlow = new THREE.Mesh(emeraldGlowGeometry, emeraldGlowMaterial);
                            collectible.add(emeraldGlow);
                            break;

                        case 'diamondFish':
                            // Add diamond sparkles and glow
                            const diamondGlowGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                            const diamondGlowMaterial = new THREE.MeshBasicMaterial({
                                color: 0x00FFFF,
                                transparent: true,
                                opacity: 0.3
                            });
                            const diamondGlow = new THREE.Mesh(diamondGlowGeometry, diamondGlowMaterial);
                            collectible.add(diamondGlow);

                            // Add diamond facets
                            for (let i = 0; i < 8; i++) {
                                const facetGeometry = new THREE.PlaneGeometry(0.1, 0.1);
                                const facetMaterial = new THREE.MeshBasicMaterial({
                                    color: 0xFFFFFF,
                                    transparent: true,
                                    opacity: 0.5,
                                    side: THREE.DoubleSide
                                });
                                const facet = new THREE.Mesh(facetGeometry, facetMaterial);
                                const angle = (i / 8) * Math.PI * 2;
                                facet.position.set(
                                    Math.cos(angle) * 0.2,
                                    Math.sin(angle) * 0.2,
                                    0
                                );
                                facet.rotation.z = angle;
                                collectible.add(facet);
                            }
                            break;
                    }

                } else {
                    // Handle other collectible types
                    switch(selectedType.shape) {
                        case 'clam':
                            // Create clam group
                            collectible = new THREE.Group();
                            
                            // Create clam shell (bottom)
                            const bottomShellGeometry = new THREE.SphereGeometry(0.4, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
                            const shellMaterial = new THREE.MeshStandardMaterial({
                                color: selectedType.color,
                                roughness: 0.7,
                                metalness: 0.3,
                                emissive: selectedType.color,
                                emissiveIntensity: 0.2
                            });
                            const bottomShell = new THREE.Mesh(bottomShellGeometry, shellMaterial);
                            bottomShell.rotation.x = Math.PI;
                            collectible.add(bottomShell);

                            // Create clam shell (top)
                            const topShellGeometry = new THREE.SphereGeometry(0.4, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
                            const topShell = new THREE.Mesh(topShellGeometry, shellMaterial);
                            topShell.rotation.x = Math.PI;
                            topShell.position.y = 0.2;
                            collectible.add(topShell);

                            // Add pearl for high-value clam
                            if (selectedType.points >= 15) {
                                const pearlGeometry = new THREE.SphereGeometry(0.1, 16, 16);
                                const pearlMaterial = new THREE.MeshStandardMaterial({
                                    color: 0xFFFFFF,
                                    roughness: 0.2,
                                    metalness: 0.8,
                                    emissive: 0xFFFFFF,
                                    emissiveIntensity: 0.5
                                });
                                const pearl = new THREE.Mesh(pearlGeometry, pearlMaterial);
                                pearl.position.y = 0.1;
                                collectible.add(pearl);
                            }
                            break;

                        case 'seahorse':
                            // Create seahorse group
                            collectible = new THREE.Group();
                            
                            // Create seahorse body
                            const seahorseBodyGeometry = new THREE.CylinderGeometry(0.1, 0.2, 0.8, 32);
                            const seahorseMaterial = new THREE.MeshStandardMaterial({
                                color: selectedType.color,
                                roughness: 0.7,
                                metalness: 0.3,
                                emissive: selectedType.color,
                                emissiveIntensity: 0.2
                            });
                            const seahorseBody = new THREE.Mesh(seahorseBodyGeometry, seahorseMaterial);
                            seahorseBody.rotation.x = Math.PI / 2;
                            collectible.add(seahorseBody);

                            // Create seahorse head
                            const headGeometry = new THREE.ConeGeometry(0.15, 0.3, 32);
                            const head = new THREE.Mesh(headGeometry, seahorseMaterial);
                            head.position.set(0, 0.4, 0);
                            head.rotation.x = -Math.PI / 2;
                            collectible.add(head);

                            // Create seahorse tail
                            const tailCurve = new THREE.CatmullRomCurve3([
                                new THREE.Vector3(0, -0.4, 0),
                                new THREE.Vector3(0.2, -0.5, 0),
                                new THREE.Vector3(0.3, -0.4, 0),
                                new THREE.Vector3(0.4, -0.5, 0)
                            ]);
                            const tailGeometry = new THREE.TubeGeometry(tailCurve, 20, 0.05, 8, false);
                            const tail = new THREE.Mesh(tailGeometry, seahorseMaterial);
                            collectible.add(tail);

                            // Add fins
                            const finGeometry = new THREE.ConeGeometry(0.1, 0.2, 4);
                            const finMaterial = new THREE.MeshStandardMaterial({
                                color: selectedType.color,
                                roughness: 0.7,
                                metalness: 0.3
                            });
                            
                            // Dorsal fin
                            const dorsalFin = new THREE.Mesh(finGeometry, finMaterial);
                            dorsalFin.position.set(0, 0.2, 0);
                            dorsalFin.rotation.x = Math.PI / 2;
                            collectible.add(dorsalFin);

                            // Pectoral fins
                            const leftPectoralFin = new THREE.Mesh(finGeometry, finMaterial);
                            leftPectoralFin.position.set(0.1, 0, 0.1);
                            leftPectoralFin.rotation.z = Math.PI / 2;
                            collectible.add(leftPectoralFin);

                            const rightPectoralFin = new THREE.Mesh(finGeometry, finMaterial);
                            rightPectoralFin.position.set(-0.1, 0, 0.1);
                            rightPectoralFin.rotation.z = -Math.PI / 2;
                            collectible.add(rightPectoralFin);
                            break;

                        case 'jellyfish':
                            // Create jellyfish group
                            collectible = new THREE.Group();
                            
                            // Create jellyfish body
                            const jellyBodyGeometry = new THREE.SphereGeometry(0.3, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
                            const jellyMaterial = new THREE.MeshStandardMaterial({
                                color: selectedType.color,
                                roughness: 0.3,
                                metalness: 0.1,
                                transparent: true,
                                opacity: 0.8
                            });
                            const jellyBody = new THREE.Mesh(jellyBodyGeometry, jellyMaterial);
                            jellyBody.rotation.x = Math.PI;
                            collectible.add(jellyBody);

                            // Add tentacles
                            const tentacleCount = selectedType.points >= 12 ? 8 : 6;
                            for (let i = 0; i < tentacleCount; i++) {
                                const angle = (i / tentacleCount) * Math.PI * 2;
                                const tentacleCurve = new THREE.CatmullRomCurve3([
                                    new THREE.Vector3(Math.cos(angle) * 0.2, 0, Math.sin(angle) * 0.2),
                                    new THREE.Vector3(Math.cos(angle) * 0.3, -0.2, Math.sin(angle) * 0.3),
                                    new THREE.Vector3(Math.cos(angle) * 0.2, -0.4, Math.sin(angle) * 0.2)
                                ]);
                                const tentacleGeometry = new THREE.TubeGeometry(tentacleCurve, 20, 0.02, 8, false);
                                const tentacle = new THREE.Mesh(tentacleGeometry, jellyMaterial);
                                collectible.add(tentacle);
                            }

                            // Add glow effect for high-value jellyfish
                            if (selectedType.points >= 12) {
                                const glowGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                                const glowMaterial = new THREE.MeshBasicMaterial({
                                    color: selectedType.color,
                                    transparent: true,
                                    opacity: 0.3
                                });
                                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                                collectible.add(glow);
                            }
                            break;

                        case 'starfish':
                            // Create starfish group
                            collectible = new THREE.Group();
                            
                            // Create starfish body
                            const starGeometry = new THREE.StarGeometry(0.4, 5, 0.2);
                            const starMaterial = new THREE.MeshStandardMaterial({
                                color: selectedType.color,
                                roughness: 0.7,
                                metalness: 0.3,
                                emissive: selectedType.color,
                                emissiveIntensity: 0.2
                            });
                            const star = new THREE.Mesh(starGeometry, starMaterial);
                            star.rotation.x = Math.PI / 2;
                            collectible.add(star);

                            // Add texture details
                            const detailGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                            const detailMaterial = new THREE.MeshStandardMaterial({
                                color: 0xFFFFFF,
                                roughness: 0.5,
                                metalness: 0.5
                            });
                            
                            // Add details based on point value
                            const detailCount = selectedType.points >= 6 ? 8 : 4;
                            for (let i = 0; i < detailCount; i++) {
                                const angle = (i / detailCount) * Math.PI * 2;
                                const detail = new THREE.Mesh(detailGeometry, detailMaterial);
                                detail.position.set(
                                    Math.cos(angle) * 0.2,
                                    0.1,
                                    Math.sin(angle) * 0.2
                                );
                                collectible.add(detail);
                            }
                            break;
                    }
                }

                collectible.position.x = (Math.random() - 0.5) * 12;
                collectible.position.z = -30;
                collectible.position.y = -0.3;
                collectible.rotation.y = Math.PI / 2;  // Face forward
                collectible.userData = {
                    type: selectedType.type,
                    points: selectedType.points,
                    emoji: selectedType.emoji
                };
                collectible.castShadow = true;

                // Add green glow plane under the collectible
                const glowGeometry = new THREE.CircleGeometry(0.8, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00FF00,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.rotation.x = -Math.PI / 2;
                glow.position.y = -0.1;
                collectible.add(glow);

                this.scene.add(collectible);
                this.collectibles.push(collectible);
            }

            updateCollectibles() {
                for (let i = this.collectibles.length - 1; i >= 0; i--) {
                    const collectible = this.collectibles[i];
                    collectible.position.z += this.obstacleSpeed;

                    // Check collection
                    if (this.checkCollection(this.otter, collectible)) {
                        this.score += collectible.userData.points;
                        this.updateScore();
                        this.scene.remove(collectible);
                        this.collectibles.splice(i, 1);

                        // Check for crown unlock
                        if (this.score >= 300 && !this.unlockedItems.includes('crown')) {
                            this.unlockedItems.push('crown');
                            localStorage.setItem('unlockedItems', JSON.stringify(this.unlockedItems));
                            
                            // Update the crown button in the UI
                            const crownButton = document.querySelector('.unlockable:nth-child(2) button');
                            if (crownButton) {
                                crownButton.disabled = false;
                                crownButton.textContent = 'Wear';
                                crownButton.parentElement.classList.remove('locked');
                                crownButton.parentElement.querySelector('span:nth-child(2)').textContent = 'Unlocked!';
                            }
                            
                            this.wearCrown();
                        }
                    }

                    // Remove collectibles that are behind the camera
                    if (collectible.position.z > 10) {
                        this.scene.remove(collectible);
                        this.collectibles.splice(i, 1);
                    }
                }
            }

            checkCollection(otter, collectible) {
                const distance = otter.position.distanceTo(collectible.position);
                return distance < 1;
            }

            startGame() {
                console.log('Start game called');
                this.isPlaying = true;
                this.gameOver = false;
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.levelTimer = 30;
                this.lastLevelTime = Date.now();
                this.obstacleSpeed = 0.2;
                this.spawnRate = 0.05;  // Increased from 0.02
                this.collectibleSpawnRate = 0.02;  // Increased from 0.01
                
                // Update UI
                this.updateScore();
                this.updateLives();
                this.updateLevel();
                
                // Hide home screen
                const homeScreen = document.getElementById('home-screen');
                if (homeScreen) {
                    console.log('Hiding home screen');
                    homeScreen.style.display = 'none';
                }
                
                // Reset otter position
                if (this.otter) {
                    console.log('Resetting otter position');
                    this.otter.position.set(0, 0, 0);
                }
                
                // Clear existing obstacles and collectibles
                this.obstacles.forEach(obstacle => this.scene.remove(obstacle));
                this.obstacles = [];
                this.collectibles.forEach(collectible => this.scene.remove(collectible));
                this.collectibles = [];
                
                // Start the game loop if it's not already running
                if (!this.gameLoopRunning) {
                    console.log('Starting game loop');
                    this.gameLoopRunning = true;
                    this.animate();
                }
            }

            showGameOver() {
                // Update top scores
                this.topScores.push({ score: this.score, date: new Date().toISOString() });
                this.topScores.sort((a, b) => b.score - a.score);
                this.topScores = this.topScores.slice(0, 10);
                localStorage.setItem('topScores', JSON.stringify(this.topScores));

                const gameOverDiv = document.createElement('div');
                gameOverDiv.style.position = 'absolute';
                gameOverDiv.style.top = '50%';
                gameOverDiv.style.left = '50%';
                gameOverDiv.style.transform = 'translate(-50%, -50%)';
                gameOverDiv.style.color = 'white';
                gameOverDiv.style.fontSize = '32px';
                gameOverDiv.style.textAlign = 'center';
                gameOverDiv.style.background = 'rgba(0,0,0,0.8)';
                gameOverDiv.style.padding = '20px';
                gameOverDiv.style.borderRadius = '10px';
                gameOverDiv.innerHTML = `Game Over!<br>Score: ${this.score}<br>Tap to restart`;
                
                this.container.appendChild(gameOverDiv);
                
                this.container.addEventListener('touchstart', () => {
                    location.reload();
                }, { once: true });
            }

            animate() {
                if (this.gameOver) {
                    console.log('Game over, stopping animation');
                    return;
                }

                requestAnimationFrame(this.animate.bind(this));

                if (this.isPlaying && !this.gameOver) {
                    // Update timer
                    const currentTime = Date.now();
                    const deltaTime = (currentTime - this.lastLevelTime) / 1000;
                    this.levelTimer -= deltaTime;
                    this.lastLevelTime = currentTime;
                    this.updateTimer();

                    // Level up every 30 seconds
                    if (this.levelTimer <= 0) {
                        this.level++;
                        this.levelTimer = 30;
                        this.obstacleSpeed += 0.05;
                        this.spawnRate += 0.005;
                        this.collectibleSpawnRate += 0.002;
                        this.updateLevel();
                    }

                    this.updateOtterPosition();
                }

                // Spawn obstacles randomly
                if (Math.random() < this.spawnRate) {
                    this.spawnObstacle();
                }

                // Spawn collectibles randomly
                if (Math.random() < this.collectibleSpawnRate) {
                    this.spawnCollectible();
                }

                this.updateObstacles();
                this.updateCollectibles();

                // Enhanced water animation
                const time = Date.now() * 0.001;
                if (this.water) {
                    const positions = this.water.geometry.attributes.position;
                    const vertex = new THREE.Vector3();
                    
                    for (let i = 0; i < positions.count; i++) {
                        vertex.fromBufferAttribute(positions, i);
                        // More complex wave pattern
                        vertex.y = Math.sin(time + vertex.x * 0.1 + vertex.z * 0.1) * 0.1 +
                                 Math.sin(time * 0.5 + vertex.x * 0.2 + vertex.z * 0.2) * 0.05;
                        positions.setY(i, vertex.y);
                    }
                    positions.needsUpdate = true;
                }

                // Enhanced cloud animation
                if (this.clouds) {
                    this.clouds.forEach(cloud => {
                        cloud.position.z += cloud.userData.speed;
                        // Add subtle floating motion
                        cloud.position.y += Math.sin(Date.now() * 0.001 + cloud.position.x) * 0.001;
                        if (cloud.position.z > 20) {
                            cloud.position.z = -100;
                            cloud.position.x = (Math.random() - 0.5) * 100;
                            cloud.position.y = Math.random() * 20 + 10;
                        }
                    });
                }

                this.renderer.render(this.scene, this.camera);
            }

            setupControls() {
                const joystickBase = document.getElementById('joystick-base');
                const joystickKnob = document.getElementById('joystick-knob');
                let isDragging = false;
                let startX = 0;
                let startY = 0;
                let baseX = 0;
                let baseY = 0;
                const maxDistance = 30; // Maximum distance the knob can move from center

                // Touch start event
                document.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;
                    
                    // Position the joystick base at touch point
                    joystickBase.style.display = 'block';
                    joystickBase.style.left = `${startX}px`;
                    joystickBase.style.bottom = `${window.innerHeight - startY}px`;
                    baseX = startX;
                    baseY = startY;
                    
                    isDragging = true;
                    updateJoystick(touch.clientX, touch.clientY);
                });

                // Touch move event
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!isDragging) return;
                    
                    const touch = e.touches[0];
                    updateJoystick(touch.clientX, touch.clientY);
                });

                // Touch end event
                document.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    isDragging = false;
                    joystickBase.style.display = 'none';
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                    this.moveDirection = 0;
                });

                // Touch cancel event
                document.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    isDragging = false;
                    joystickBase.style.display = 'none';
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                    this.moveDirection = 0;
                });

                function updateJoystick(x, y) {
                    // Calculate distance and angle from center
                    const deltaX = x - baseX;
                    const deltaY = y - baseY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const angle = Math.atan2(deltaY, deltaX);

                    // Limit the distance
                    const limitedDistance = Math.min(distance, maxDistance);
                    
                    // Calculate new position
                    const newX = Math.cos(angle) * limitedDistance;
                    const newY = Math.sin(angle) * limitedDistance;

                    // Update knob position
                    joystickKnob.style.transform = `translate(calc(-50% + ${newX}px), calc(-50% + ${newY}px))`;

                    // Update movement direction (-1 to 1)
                    this.moveDirection = newX / maxDistance;
                }
            }

            loadOtter() {
                // Create otter group
                this.otter = new THREE.Group();
                this.otter.position.y = -0.9;  // Lower otter position to be in blue water
                this.otter.scale.set(0.8, 0.8, 0.8);
                this.scene.add(this.otter);

                // Create body
                const bodyGeometry = new THREE.SphereGeometry(0.4, 32, 32);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.1;
                body.rotation.y = Math.PI / 2;
                body.scale.set(1.2, 0.8, 0.8);
                this.otter.add(body);

                // Create head
                const headGeometry = new THREE.SphereGeometry(0.25, 32, 32);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.set(0, 0.2, -0.7);
                head.rotation.y = Math.PI / 2;
                head.scale.set(1, 0.6, 0.8);
                this.otter.add(head);

                // Create snout
                const snoutGeometry = new THREE.ConeGeometry(0.12, 0.25, 8);
                const snoutMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
                snout.position.set(0, 0.2, -0.9);
                snout.rotation.x = Math.PI / 2;
                snout.rotation.y = Math.PI / 2;
                snout.scale.set(1, 0.6, 0.8);
                this.otter.add(snout);

                // Create eyes
                const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const eyeMaterial = new THREE.MeshStandardMaterial({
                    color: 0x000000,
                    roughness: 0.3,
                    metalness: 0.8
                });
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(0.12, 0.3, -0.8);
                leftEye.rotation.y = Math.PI / 2;
                this.otter.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(-0.12, 0.3, -0.8);
                rightEye.rotation.y = Math.PI / 2;
                this.otter.add(rightEye);

                // Create ears
                const earGeometry = new THREE.SphereGeometry(0.06, 32, 32);
                const earMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const leftEar = new THREE.Mesh(earGeometry, earMaterial);
                leftEar.position.set(0.12, 0.35, -0.65);
                leftEar.rotation.y = Math.PI / 2;
                this.otter.add(leftEar);
                const rightEar = new THREE.Mesh(earGeometry, earMaterial);
                rightEar.position.set(-0.12, 0.35, -0.65);
                rightEar.rotation.y = Math.PI / 2;
                this.otter.add(rightEar);

                // Create oval tail
                const tailGeometry = new THREE.SphereGeometry(0.3, 32, 32);
                const tailMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                tail.position.set(0, 0.1, 0.7);
                tail.rotation.y = Math.PI / 2;  // Rotate 90 degrees on Y axis
                tail.rotation.x = Math.PI / 2;  // Rotate 90 degrees on X axis
                tail.rotation.z = Math.PI / 2;  // Rotate 90 degrees on Z axis
                tail.scale.set(2.5, 0.05, 0.4);  // Decreased height from 0.8 to 0.4
                this.otter.add(tail);

                // Create legs (shorter)
                const legGeometry = new THREE.CapsuleGeometry(0.1, 0.2, 4, 8);
                const legMaterial = new THREE.MeshStandardMaterial({
                    color: 0xD2691E,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
                frontLeftLeg.position.set(0.25, -0.1, -0.3);
                frontLeftLeg.rotation.y = Math.PI / 2;
                frontLeftLeg.scale.set(1, 0.4, 1);
                this.otter.add(frontLeftLeg);
                const frontRightLeg = new THREE.Mesh(legGeometry, legMaterial);
                frontRightLeg.position.set(-0.25, -0.1, -0.3);
                frontRightLeg.rotation.y = Math.PI / 2;
                frontRightLeg.scale.set(1, 0.4, 1);
                this.otter.add(frontRightLeg);
                const backLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
                backLeftLeg.position.set(0.25, -0.1, 0.3);
                backLeftLeg.rotation.y = Math.PI / 2;
                backLeftLeg.scale.set(1, 0.4, 1);
                this.otter.add(backLeftLeg);
                const backRightLeg = new THREE.Mesh(legGeometry, legMaterial);
                backRightLeg.position.set(-0.25, -0.1, 0.3);
                backRightLeg.rotation.y = Math.PI / 2;
                backRightLeg.scale.set(1, 0.4, 1);
                this.otter.add(backRightLeg);
            }

            updateObstacles() {
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    obstacle.position.z += this.obstacleSpeed;

                    // Apply rotation animation for certain obstacles
                    if (obstacle.userData.rotationSpeed) {
                        obstacle.rotation.x += obstacle.userData.rotationSpeed.x;
                        obstacle.rotation.y += obstacle.userData.rotationSpeed.y;
                        obstacle.rotation.z += obstacle.userData.rotationSpeed.z;
                    }

                    // Check collision
                    if (this.checkCollision(this.otter, obstacle)) {
                        // Remove the obstacle after collision
                        this.scene.remove(obstacle);
                        this.obstacles.splice(i, 1);
                        continue;
                    }

                    // Remove obstacles that are behind the camera
                    if (obstacle.position.z > 10) {
                        this.scene.remove(obstacle);
                        this.obstacles.splice(i, 1);
                        // Removed points for avoiding obstacles
                    }
                }
            }

            checkCollision(otter, obstacle) {
                const distance = otter.position.distanceTo(obstacle.position);
                let collisionRadius;
                let isCollision = false;
                
                if (obstacle.geometry.type === 'CylinderGeometry') {
                    // For wooden poles, check both horizontal distance and vertical position
                    const horizontalDistance = Math.sqrt(
                        Math.pow(otter.position.x - obstacle.position.x, 2) +
                        Math.pow(otter.position.z - obstacle.position.z, 2)
                    );
                    const verticalDistance = Math.abs(otter.position.y - obstacle.position.y);
                    collisionRadius = 0.4; // Increased from 0.3
                    
                    // Check if otter is within the pole's height range and horizontal distance
                    isCollision = horizontalDistance < collisionRadius && verticalDistance < 1.0;
                } else {
                    // For rocks, use simple distance check
                    collisionRadius = 0.5;
                    isCollision = distance < collisionRadius;
                }

                if (isCollision) {
                    this.lives--;
                    this.updateLives();
                    
                    // Only end game when all lives are lost
                    if (this.lives <= 0) {
                        this.gameOver = true;
                        this.showGameOver();
                    }
                    return true;
                }
                return false;
            }

            spawnObstacle() {
                // Define obstacle types with their properties
                const obstacleTypes = [
                    { type: 'rock', chance: 0.3, 
                      geometry: new THREE.DodecahedronGeometry(0.5, 2),  // Increased detail level
                      material: new THREE.MeshStandardMaterial({ 
                          color: 0x808080,
                          roughness: 0.9,  // Increased roughness
                          metalness: 0.1,  // Reduced metalness
                          flatShading: true  // Add flat shading for more angular look
                      }),
                      yPos: -0.3, scale: 1.0 },
                    { type: 'pole', chance: 0.2, geometry: new THREE.CylinderGeometry(0.15, 0.15, 2, 8),
                      material: new THREE.MeshStandardMaterial({ 
                          color: 0x8B4513,
                          roughness: 0.9, 
                          metalness: 0.1
                      }),
                      yPos: 0.5, scale: 1.0 },
                    { type: 'log', chance: 0.15, geometry: new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8),
                      material: new THREE.MeshStandardMaterial({ 
                          color: 0x8B4513,
                          roughness: 0.9, 
                          metalness: 0.1
                      }),
                      yPos: -0.2, scale: 1.0 },
                    { type: 'iceberg', chance: 0.15, geometry: new THREE.ConeGeometry(0.4, 1.2, 4),
                      material: new THREE.MeshStandardMaterial({ 
                          color: 0xADD8E6,
                          roughness: 0.3, 
                          metalness: 0.1
                      }),
                      yPos: -0.1, scale: 1.0 },
                    { type: 'debris', chance: 0.1, geometry: new THREE.TetrahedronGeometry(0.4, 0),
                      material: new THREE.MeshStandardMaterial({ 
                          color: 0x696969,
                          roughness: 0.7, 
                          metalness: 0.3
                      }),
                      yPos: -0.3, scale: 1.0 },
                    { type: 'floatingMine', chance: 0.1, geometry: new THREE.SphereGeometry(0.3, 16, 16),
                      material: new THREE.MeshStandardMaterial({ 
                          color: 0x000000,
                          roughness: 0.5, 
                          metalness: 0.5
                      }),
                      yPos: -0.2, scale: 1.0 }
                ];

                // Select obstacle type based on chances
                const totalChance = obstacleTypes.reduce((sum, type) => sum + type.chance, 0);
                let random = Math.random() * totalChance;
                let selectedType;
                let currentSum = 0;

                for (const type of obstacleTypes) {
                    currentSum += type.chance;
                    if (random <= currentSum) {
                        selectedType = type;
                        break;
                    }
                }

                // Create the obstacle
                const obstacle = new THREE.Mesh(selectedType.geometry, selectedType.material);
                obstacle.position.x = (Math.random() - 0.5) * 12;
                obstacle.position.z = -30;
                obstacle.position.y = selectedType.yPos;
                obstacle.scale.set(selectedType.scale, selectedType.scale, selectedType.scale);
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;

                // Add red glow plane under the obstacle
                const glowGeometry = new THREE.CircleGeometry(0.8, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFF0000,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.rotation.x = -Math.PI / 2;
                glow.position.y = -0.1;
                obstacle.add(glow);

                // Add special behaviors and features for each obstacle type
                switch(selectedType.type) {
                    case 'rock':
                        // Add surface details to rock
                        const rock = obstacle;
                        rock.geometry.attributes.position.needsUpdate = true;
                        rock.geometry.computeVertexNormals();
                        
                        // Add random displacement to vertices for more natural look
                        const positions = rock.geometry.attributes.position;
                        for (let i = 0; i < positions.count; i++) {
                            const x = positions.getX(i);
                            const y = positions.getY(i);
                            const z = positions.getZ(i);
                            
                            // Add random displacement
                            positions.setXYZ(
                                i,
                                x + (Math.random() - 0.5) * 0.1,
                                y + (Math.random() - 0.5) * 0.1,
                                z + (Math.random() - 0.5) * 0.1
                            );
                        }
                        
                        // Add some smaller rocks around the main rock
                        for (let i = 0; i < 3; i++) {
                            const smallRockGeometry = new THREE.DodecahedronGeometry(0.15, 1);
                            const smallRock = new THREE.Mesh(smallRockGeometry, selectedType.material);
                            const angle = (i / 3) * Math.PI * 2;
                            smallRock.position.set(
                                Math.cos(angle) * 0.4,
                                -0.1,
                                Math.sin(angle) * 0.4
                            );
                            smallRock.rotation.set(
                                Math.random() * Math.PI,
                                Math.random() * Math.PI,
                                Math.random() * Math.PI
                            );
                            rock.add(smallRock);
                        }
                        break;

                    case 'pole':
                        // Add rope wrapping
                        const ropeGeometry = new THREE.TorusGeometry(0.17, 0.03, 8, 16);
                        const ropeMaterial = new THREE.MeshStandardMaterial({
                            color: 0x8B4513,
                            roughness: 0.9,
                            metalness: 0.1
                        });
                        for (let i = 0; i < 3; i++) {
                            const rope = new THREE.Mesh(ropeGeometry, ropeMaterial);
                            rope.position.y = -0.5 + i * 0.5;
                            rope.rotation.x = Math.PI / 2;
                            obstacle.add(rope);
                        }
                        break;

                    case 'log':
                        // Add bark texture and knots
                        const barkGeometry = new THREE.CylinderGeometry(0.22, 0.22, 1.5, 8);
                        const barkMaterial = new THREE.MeshStandardMaterial({
                            color: 0x654321,
                            roughness: 1.0,
                            metalness: 0.0
                        });
                        const bark = new THREE.Mesh(barkGeometry, barkMaterial);
                        obstacle.add(bark);
                        
                        // Add knots
                        for (let i = 0; i < 3; i++) {
                            const knotGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                            const knotMaterial = new THREE.MeshStandardMaterial({
                                color: 0x4B2A0A,
                                roughness: 1.0,
                                metalness: 0.0
                            });
                            const knot = new THREE.Mesh(knotGeometry, knotMaterial);
                            knot.position.set(
                                (Math.random() - 0.5) * 0.3,
                                (Math.random() - 0.5) * 1.2,
                                0.2
                            );
                            obstacle.add(knot);
                        }
                        break;

                    case 'iceberg':
                        // Add snow cap and icicles
                        const snowCapGeometry = new THREE.ConeGeometry(0.45, 0.3, 4);
                        const snowMaterial = new THREE.MeshStandardMaterial({
                            color: 0xFFFFFF,
                            roughness: 0.3,
                            metalness: 0.1
                        });
                        const snowCap = new THREE.Mesh(snowCapGeometry, snowMaterial);
                        snowCap.position.y = 0.6;
                        obstacle.add(snowCap);

                        // Add icicles
                        for (let i = 0; i < 4; i++) {
                            const icicleGeometry = new THREE.ConeGeometry(0.05, 0.2, 4);
                            const icicleMaterial = new THREE.MeshStandardMaterial({
                                color: 0xADD8E6,
                                roughness: 0.2,
                                metalness: 0.3,
                                transparent: true,
                                opacity: 0.8
                            });
                            const icicle = new THREE.Mesh(icicleGeometry, icicleMaterial);
                            const angle = (i / 4) * Math.PI * 2;
                            icicle.position.set(
                                Math.cos(angle) * 0.3,
                                0.3,
                                Math.sin(angle) * 0.3
                            );
                            icicle.rotation.x = Math.PI;
                            obstacle.add(icicle);
                        }
                        break;

                    case 'debris':
                        // Add rust spots and sharp edges
                        const rustGeometry = new THREE.SphereGeometry(0.42, 8, 8);
                        const rustMaterial = new THREE.MeshStandardMaterial({
                            color: 0x8B0000,
                            roughness: 0.9,
                            metalness: 0.3
                        });
                        const rust = new THREE.Mesh(rustGeometry, rustMaterial);
                        obstacle.add(rust);

                        // Add sharp edges
                        for (let i = 0; i < 4; i++) {
                            const edgeGeometry = new THREE.ConeGeometry(0.05, 0.2, 4);
                            const edgeMaterial = new THREE.MeshStandardMaterial({
                                color: 0x696969,
                                roughness: 0.7,
                                metalness: 0.3
                            });
                            const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
                            const angle = (i / 4) * Math.PI * 2;
                            edge.position.set(
                                Math.cos(angle) * 0.3,
                                Math.sin(angle) * 0.3,
                                0
                            );
                            edge.rotation.x = Math.PI / 2;
                            edge.rotation.z = angle;
                            obstacle.add(edge);
                        }
                        break;

                    case 'floatingMine':
                        // Add spikes and warning lights
                        const spikeGeometry = new THREE.ConeGeometry(0.1, 0.2, 8);
                        const spikeMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0x000000, 
                            roughness: 0.5, 
                            metalness: 0.5
                        });
                        for (let i = 0; i < 8; i++) {
                            const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                            const angle = (i / 8) * Math.PI * 2;
                            spike.position.set(
                                Math.cos(angle) * 0.3,
                                Math.sin(angle) * 0.3,
                                0
                            );
                            spike.rotation.x = Math.PI / 2;
                            spike.rotation.z = angle;
                            obstacle.add(spike);
                        }

                        // Add warning lights
                        for (let i = 0; i < 4; i++) {
                            const lightGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                            const lightMaterial = new THREE.MeshBasicMaterial({
                                color: 0xFF0000,
                                emissive: 0xFF0000,
                                emissiveIntensity: 1.0
                            });
                            const light = new THREE.Mesh(lightGeometry, lightMaterial);
                            const angle = (i / 4) * Math.PI * 2;
                            light.position.set(
                                Math.cos(angle) * 0.3,
                                Math.sin(angle) * 0.3,
                                0
                            );
                            obstacle.add(light);
                        }
                        break;
                }

                this.scene.add(obstacle);
                this.obstacles.push(obstacle);
            }

            updateScore() {
                const scoreElement = document.getElementById('score');
                if (scoreElement) {
                    scoreElement.textContent = `Score: ${this.score}`;
                    // Ensure minimum width to prevent layout shifts
                    scoreElement.style.minWidth = '120px';
                }
            }

            updateOtterPosition() {
                if (this.otter) {
                    this.otter.position.x += this.moveDirection * this.moveSpeed;
                    // Keep otter within bounds
                    this.otter.position.x = Math.max(-8, Math.min(8, this.otter.position.x));
                }
            }

            updateLives() {
                const livesContainer = document.getElementById('lives');
                const lives = livesContainer.getElementsByClassName('life');
                for (let i = 0; i < lives.length; i++) {
                    lives[i].classList.toggle('lost', i >= this.lives);
                }
            }

            updateLevel() {
                const levelElement = document.getElementById('level');
                if (levelElement) {
                    levelElement.textContent = `Level: ${this.level}`;
                    // Ensure minimum width to prevent layout shifts
                    levelElement.style.minWidth = '100px';
                }
            }

            updateTimer() {
                const timerElement = document.getElementById('timer');
                if (timerElement) {
                    timerElement.textContent = `Time: ${Math.ceil(this.levelTimer)}`;
                    // Ensure minimum width to prevent layout shifts
                    timerElement.style.minWidth = '100px';
                }
            }
        }
    </script>
</body>
</html> 